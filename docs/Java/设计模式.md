[TOC]



## 1.设计模式分类

### 1.1 创造型模式
>  1. 工厂方法模式
>  2. 抽象工厂方法模式
>  3. 单例模式
>  4. 建造者模式
>  5. 原型模式

### 1.2 结构型模式

>  1. 适配器模式
>  2. 装饰器模式
>  3. 代理模式
>  4. 外观模式
>  5. 桥接模式
>  6. 组合模式
>  7. 享元模式

### 1.3 行为型模式

>  1. 策略模式
>  2. 模板方法模式
>  3. 观察者模式
>  4. 迭代子模式
>  5. 责任链模式
>  6. 命令模式
>  7. 备忘录模式
>  8. 状态模式
>  9. 访问者模式
>  10. 中介者模式
>  11. 解释器模式

## 2.设计模式的六大原则

### 2.1 总原则：开闭原则(Open Close Principle 缩写：OCP)

>​	开闭原则就是说**对扩展开放，对修改关闭**。即软件实体应尽量在不修改原有代码的情况下进行扩展。

#### 2.1.1 为什么使用开闭原则

1. 开闭原则非常有名，只要是面向对象编程，在开发时都会强调开闭原则。

 2. 开闭原则是最基础的设计原则，其它的五个设计原则都是开闭原则的具体形态，也就是说其它的五个设计原则是指导设计的工具和方法，而开闭原则才是其精神领袖。依照Java语言的称谓，开闭原则是抽象类，而其它的五个原则是具体的实现类。

 3. 开闭原则可以提高复用性。

    在面向对象的设计中，所有的逻辑都是从原子逻辑组合而来，不是在一个类中独立实现一个业务逻辑。只有这样的代码才可以复用，粒度越小，被复用的可能性越大。那为什么要复用呢？减少代码的重复，避免相同的逻辑分散在多个角落，减少维护人员的工作量。那怎么才能提高复用率呢？缩小逻辑粒度，知道一个逻辑不可以分为止。

 4. 开闭原则可以提高维护性。

    一款软件量产后，维护人员的工作不仅仅对数据进行维护，还可能要对程序进行扩展，维护人员最乐意的事是扩展一个类，而不是修改一个类。让维护人员读懂原有代码，在进行修改，是一件非常痛苦的事情，不要让他在原有的代码海洋中游荡后在修改，那是对维护人员的折磨和摧残。

 5. 面向对象开发的要求。

    万物皆对象，我们要把所有的事物抽象成对象，然后针对对象进行操作，但是万物皆发展变化，有变化就要有策略去应对，怎么快速应对呢？这就需要在设计之初考虑到所有可能变化的因素，然后留下接口，等待“可能”转变为“现实”。

#### 2.1.2 如何使用开闭原则

1. **抽象约束**
    抽象是对一组事务的通用描述，没有具体的实现，也就表示他可以有非常多的可能性，可以跟随需求的变化而变化。因此，通过接口或抽象类可以约束一组可能变化的行为，并且能过实现对扩展开放，其包含三层含义：

  > * 通过接口或者抽象类约束扩散，对扩展进行边界限定，不允许出现在接口或抽象勒种不存在的`public`方法。
  >
  >  * 参数类型，引用对象尽量使用接口或者抽象类，而不是实现类，这主要是实现里氏替换原则的一个要求。
  >  * 抽象层尽量保持稳定，一旦确定就不要修改。


2. **元数据(metadata)控件模块行为**

   什么是元数据：用来描述环境和数据的数据，通俗来说就是配置参数，参数可以从文件中获取，也可以从数据库中获取。

3. **制定项目章程**

   在一个团队中，建立项目章程是非常重要的，因为章程是所有人员都必须遵守的约定，对项目来说，约定优于配置。这比通过接口或抽象类进行约束效率更高，而扩展性一点也没有减少。

4. **封装变化**

   对变化封装包含两层含义：
    (1) 将相同的变化封装到一个接口或抽象类中
    (2) 将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。
    封装变化，也就是受保护的变化，找出预计有变化或不稳定的点，我们为这些变化点创建稳定的接口。

### 2.2 单一职责原则(Single Responsibility Principle 缩写：SRP)

> 单一职责原则又称单一功能原则，面向对象五个基本原则(SOLID)之一，它规定一个类应该只有一个发生变化的原因。该原则由罗伯特·C·马丁（Robert C. Martin）于《敏捷软件开发：原则、模式和实践》一书中给出的。马丁表示此原则是基于[汤姆·狄马克](https://baike.baidu.com/item/汤姆·狄马克/284013)(Tom DeMarco)和Meilir Page-Jones的著作中的[内聚性](https://baike.baidu.com/item/内聚性/4973441)原则发展出的。
>
> 所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。

#### 2.2.1 定义

>一个类，只有一个引起他变化的原因。应该只有一个职责。每一个职责都是变化的一个轴线，如果一个类有一个以上的职责，这些职责就耦合在了一起。这会导致脆弱的设计。当一个职责发生变化时，可能会影响其他的职责。另外，多个职责耦合在一起，会影响复用性。例如：要实现逻辑和界面的分离。 

#### 2.2.2 优点

> * 降低类的复杂度，实现什么职责都有清晰明确的定义；
> * 提高类的可读性，提高系统的可维护性；
> * 降低变更引起的风险(降低对其他功能的影响)；

#### 2.2.3 实现

> 单一职责原则关键点：要求接口的职责单一，从而实现该接口的类的职责单一。
>
> **最佳实践**
>
> - 单一职责最难划分的是职责。
> - 单一职责原则提出标准：用职责和变化原因来衡量接口或类设计的是否优良，但是职责和变化原因都是不可度量的，因项目、环境而异。
> - 接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。

### 2.3 里氏替换原则(Liskov Substitution Principle 缩写：LSP)

#### 2.3.1 定义

> ```
> 1.子类可以扩展父类的功能，但不能改变父类原有的功能。
> 2.在程序中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。
> 3.里氏替换原则是实现开闭原则的重要方式之一。由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时在确定其子类类型，用子类对象来替换父类对象。
> ```
>

#### 2.3.2 规范

>- 子类必须完全实现父类的方法。
>
>- 子类可以有自己的个性
>
>  ​	子类可以拥有自己属性和方法。
>
>- 覆盖或者实现父类的方法时，输入参数可以被放大。
>
>- 覆盖或者实现父类的方法时，输出结果可以被缩小。

#### 2.3.3 经验

>在项目中，采用历史替换原则时，尽量避免子类的“个性”，一旦子类有了“个性”，这个子类和父类之间的关系就难调和，把子类当做父类使用，子类的“个性”被抺杀了，把子类单独作为一个业务来使用，则会让代码间的耦合关系变得扑朔迷离–缺乏类替换的标准。



### 2.4 依赖倒转原则(Dependence Inversion Principle 缩写：DIP)

### 2.5 接口隔离原则(Interface Segregation Principle 缩写：ISP）

### 2.6 迪米特原则(Demeter Principle 缩写：LOD)



